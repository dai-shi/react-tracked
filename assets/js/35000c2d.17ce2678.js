"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[310],{8914:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var a=n(6070),r=n(7468);const s={id:"caveats",title:"Caveats",sidebar_label:"Caveats"},o=void 0,i={id:"caveats",title:"Caveats",description:"Proxy and state usage tracking may not work 100% as expected.",source:"@site/docs/caveats.md",sourceDirName:".",slug:"/caveats",permalink:"/docs/caveats",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"caveats",title:"Caveats",sidebar_label:"Caveats"},sidebar:"docs",previous:{title:"Debugging",permalink:"/docs/debugging"}},c={},d=[{value:"Proxied states are referentially equal only in per-hook basis",id:"proxied-states-are-referentially-equal-only-in-per-hook-basis",level:2},{value:"An object referential change doesn&#39;t trigger re-render if an property of the object is accessed in previous render (v1 only)",id:"an-object-referential-change-doesnt-trigger-re-render-if-an-property-of-the-object-is-accessed-in-previous-render-v1-only",level:2},{value:"Proxied state might behave unexpectedly outside render",id:"proxied-state-might-behave-unexpectedly-outside-render",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Proxy and state usage tracking may not work 100% as expected.\nThere are some limitations and workarounds."}),"\n",(0,a.jsx)(t.h2,{id:"proxied-states-are-referentially-equal-only-in-per-hook-basis",children:"Proxied states are referentially equal only in per-hook basis"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"const state1 = useTrackedState();\nconst state2 = useTrackedState();\n// state1 and state2 is not referentially equal\n// even if the underlying state is referentially equal.\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You should use ",(0,a.jsx)(t.code,{children:"useTrackedState"})," only once in a component\nif you need referential equality of objects in the state."]}),"\n",(0,a.jsx)(t.h2,{id:"an-object-referential-change-doesnt-trigger-re-render-if-an-property-of-the-object-is-accessed-in-previous-render-v1-only",children:"An object referential change doesn't trigger re-render if an property of the object is accessed in previous render (v1 only)"}),"\n",(0,a.jsxs)(t.p,{children:["\u26a0\ufe0f"," This caveat only applies to v1. Since v2, we don't have such limitations."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"const state = useTrackedState();\nconst { foo } = state;\nreturn <Child key={foo.id} foo={foo} />;\n\nconst Child = React.memo(({ foo }) => {\n  // ...\n};\n// if foo doesn't change, Child won't render, so foo.id is only marked as used.\n// it won't trigger Child to re-render even if foo is changed.\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You need to use a special ",(0,a.jsx)(t.code,{children:"memo"})," provided by this library."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"import { memo } from 'react-tracked';\n\nconst Child = memo(({ foo }) => {\n  // ...\n};\n"})}),"\n",(0,a.jsx)(t.h2,{id:"proxied-state-might-behave-unexpectedly-outside-render",children:"Proxied state might behave unexpectedly outside render"}),"\n",(0,a.jsx)(t.p,{children:"Proxies are basically transparent, and it should behave like normal objects.\nHowever, there can be edge cases where it behaves unexpectedly.\nFor example, if you console.log a proxied value,\nit will display a proxy wrapping an object.\nNotice, it will be kept tracking outside render,\nso any property access will mark as used to trigger re-render on updates."}),"\n",(0,a.jsx)(t.p,{children:"useTrackedState will unwrap a Proxy before wrapping with a new Proxy,\nhence, it will work fine in usual use cases.\nThere's only one known pitfall: If you wrap proxied state with your own Proxy\noutside the control of useTrackedState,\nit might lead memory leaks, because useTrackedState\nwouldn't know how to unwrap your own Proxy."}),"\n",(0,a.jsx)(t.p,{children:"To work around such edge cases, the first option is to use primitive values."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"const state = useTrackedState();\nconst dispatch = useUpdate();\ndispatch({ type: 'FOO', value: state.fooObj }); // Instead of using objects,\ndispatch({ type: 'FOO', value: state.fooStr }); // Use primitives.\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The second option is to use ",(0,a.jsx)(t.code,{children:"getUntrackedObject"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"import { getUntrackedObject } from 'react-tracked';\n\ndispatch({ type: 'FOO', value: getUntrackedObject(state.fooObj) });\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You could implement a special dispatch function to do this automatically.\nCheck out ",(0,a.jsx)(t.a,{href:"https://github.com/dai-shi/react-tracked/blob/main/examples/10_untracked/src/store.ts",children:"examples/10_untracked/src/store.ts"})," for a concrete example."]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},7468:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(758);const r={},s=a.createContext(r);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);